<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perfect Shape Hunter 2D - Game Platformer Edukatif</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        .game-container {
            position: relative;
            width: 1000px;
            height: 700px;
            background: linear-gradient(180deg, #87CEEB 0%, #90EE90 100%);
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.4);
            overflow: hidden;
            border: 3px solid rgba(255,255,255,0.3);
        }

        #gameCanvas {
            display: block;
            border-radius: 12px;
            cursor: crosshair;
        }

        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-weight: bold;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 10;
        }

        .target-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 10;
        }

        .controls-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .progress-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(30,30,30,0.95));
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 100;
            max-width: 500px;
            border: 2px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }

        .modal-title {
            font-size: 36px;
            margin-bottom: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .modal-content {
            font-size: 18px;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .modal-button {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .modal-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }

        .modal-button.secondary {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .title-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(30,30,30,0.8));
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .mobile-controls {
            position: absolute;
            bottom: 80px;
            right: 20px;
            display: none;
        }

        .mobile-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.5);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            margin: 5px;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .mobile-btn:active {
            transform: scale(0.95);
            background: rgba(255,255,255,0.4);
        }

        @media (max-width: 768px) {
            .mobile-controls { display: flex; flex-wrap: wrap; }
            .controls-panel { display: none; }
        }

        .sound-effect {
            position: absolute;
            color: #FFD700;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            z-index: 50;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="title-bar">
            üéÆ PERFECT SHAPE HUNTER 2D üîç
        </div>

        <div class="ui-panel">
            <div style="color: #FFD700;">üèÜ Skor: <span id="score">0</span></div>
            <div style="color: #87CEEB;">üìä Level: <span id="level">1</span></div>
            <div style="color: #90EE90;">‚≠ê Dikumpulkan: <span id="collected">0</span>/<span id="targetCount">5</span></div>
            <div style="color: #FF6B6B;">‚è±Ô∏è Waktu: <span id="timer">60</span>s</div>
            <div style="color: #FECA57;">üíé Bonus: <span id="bonus">0</span></div>
        </div>

        <div class="target-panel">
            <div style="margin-bottom: 10px; font-size: 16px;">üéØ Target Pencarian:</div>
            <canvas id="targetCanvas" width="80" height="80"></canvas>
            <div id="targetName" style="margin-top: 8px; font-size: 14px; color: #FFD700;">Lingkaran Merah</div>
            <div style="font-size: 12px; margin-top: 5px; color: #87CEEB;">Hindari bentuk lain!</div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
        </div>

        <div class="controls-panel">
            <div><strong>üéÆ Kontrol Game:</strong></div>
            <div>‚¨ÖÔ∏è‚û°Ô∏è A/D: Bergerak kiri/kanan</div>
            <div>‚¨ÜÔ∏è W/Space: Lompat tinggi</div>
            <div>‚¨áÔ∏è S: Turun cepat/jongkok</div>
            <div>üéØ Kumpulkan bentuk yang sesuai target!</div>
        </div>

        <div class="mobile-controls">
            <div class="mobile-btn" id="leftBtn">‚Üê</div>
            <div class="mobile-btn" id="rightBtn">‚Üí</div>
            <div class="mobile-btn" id="jumpBtn">‚Üë</div>
            <div class="mobile-btn" id="downBtn">‚Üì</div>
        </div>

        <canvas id="gameCanvas" width="1000" height="700"></canvas>

        <!-- Start Screen -->
        <div class="modal" id="startModal" style="display: block;">
            <div class="modal-title">üéÆ SHAPE HUNTER 2D</div>
            <div class="modal-content">
                Selamat datang di petualangan edukatif!<br><br>
                üéØ <strong>Misi:</strong> Kumpulkan bentuk dan warna yang sesuai target<br>
                ‚≠ê <strong>Bonus:</strong> Semakin cepat, semakin tinggi skor!<br>
                üö´ <strong>Hati-hati:</strong> Hindari bentuk yang salah!<br><br>
                <em>Game edukatif untuk semua umur</em>
            </div>
            <button class="modal-button" onclick="startGame()">üöÄ Mulai Petualangan</button>
            <button class="modal-button secondary" onclick="showInstructions()">üìñ Panduan</button>
        </div>

        <!-- Instructions -->
        <div class="modal" id="instructionsModal">
            <div class="modal-title">üìñ Panduan Bermain</div>
            <div class="modal-content">
                <strong>üéØ Cara Bermain:</strong><br>
                1. Lihat target bentuk dan warna di kanan atas<br>
                2. Gerakkan karakter untuk mengumpulkan target<br>
                3. Hindari bentuk/warna yang berbeda<br>
                4. Kumpulkan semua target sebelum waktu habis<br><br>
                
                <strong>üèÜ Sistem Poin:</strong><br>
                ‚úÖ Target benar: +100 poin<br>
                ‚ùå Target salah: -50 poin<br>
                ‚ö° Bonus kecepatan: +10 per detik tersisa<br><br>
                
                <strong>üéÆ Tips:</strong><br>
                ‚Ä¢ Lompatan ganda untuk jangkauan lebih tinggi<br>
                ‚Ä¢ Gerakan cepat untuk bonus waktu<br>
                ‚Ä¢ Perhatikan highlight emas pada target!
            </div>
            <button class="modal-button" onclick="hideInstructions()">‚¨ÖÔ∏è Kembali</button>
        </div>

        <!-- Level Complete -->
        <div class="modal" id="levelCompleteModal">
            <div class="modal-title">üéâ Level Selesai!</div>
            <div class="modal-content" id="levelCompleteContent"></div>
            <button class="modal-button" onclick="nextLevel()">‚û°Ô∏è Level Berikutnya</button>
            <button class="modal-button secondary" onclick="restartGame()">üîÑ Ulang dari Awal</button>
        </div>

        <!-- Game Over -->
        <div class="modal" id="gameOverModal">
            <div class="modal-title">‚è∞ Waktu Habis!</div>
            <div class="modal-content" id="gameOverContent"></div>
            <button class="modal-button" onclick="restartCurrentLevel()">üîÑ Coba Level Ini Lagi</button>
            <button class="modal-button secondary" onclick="restartGame()">üè† Kembali ke Level 1</button>
        </div>

        <!-- Victory -->
        <div class="modal" id="victoryModal">
            <div class="modal-title">üèÜ KEMENANGAN TOTAL!</div>
            <div class="modal-content" id="victoryContent"></div>
            <button class="modal-button" onclick="restartGame()">üéÆ Main Lagi</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const targetCanvas = document.getElementById('targetCanvas');
        const targetCtx = targetCanvas.getContext('2d');

        // Enhanced game state
        let gameState = {
            score: 0,
            level: 1,
            collected: 0,
            targetCount: 5,
            timeLeft: 60,
            gameRunning: false,
            gameStarted: false,
            camera: { x: 0, y: 0 },
            maxLevels: 10,
            bonus: 0,
            perfectStreak: 0
        };

        // Enhanced player with double jump
        const player = {
            x: 100,
            y: 500,
            width: 45,
            height: 60,
            velocityX: 0,
            velocityY: 0,
            speed: 6,
            jumpPower: 18,
            onGround: false,
            canDoubleJump: true,
            facingRight: true,
            color: '#4169E1',
            animationFrame: 0,
            crouching: false
        };

        // Enhanced shapes and colors
        const shapes = ['circle', 'square', 'triangle', 'diamond', 'star', 'hexagon', 'heart'];
        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#9B59B6', '#E67E22'];
        
        const colorNames = {
            '#FF6B6B': 'Merah', '#4ECDC4': 'Tosca', '#45B7D1': 'Biru',
            '#96CEB4': 'Hijau', '#FECA57': 'Kuning', '#FF9FF3': 'Pink',
            '#9B59B6': 'Ungu', '#E67E22': 'Oranye'
        };

        const shapeNames = {
            'circle': 'Lingkaran', 'square': 'Persegi', 'triangle': 'Segitiga',
            'diamond': 'Berlian', 'star': 'Bintang', 'hexagon': 'Segi Enam', 'heart': 'Hati'
        };

        let currentTarget = { shape: 'circle', color: '#FF6B6B' };
        let platforms = [];
        let collectibles = [];
        let particles = [];
        let clouds = [];
        let keys = {};
        let soundEffects = [];

        // Enhanced platform generation
        function generatePlatforms() {
            platforms = [
                // Ground level
                { x: 0, y: 650, width: 400, height: 50, color: '#8B4513', type: 'ground' },
                { x: 500, y: 650, width: 400, height: 50, color: '#8B4513', type: 'ground' },
                { x: 1000, y: 650, width: 400, height: 50, color: '#8B4513', type: 'ground' },
                { x: 1500, y: 650, width: 400, height: 50, color: '#8B4513', type: 'ground' },
                
                // Level 2
                { x: 200, y: 520, width: 150, height: 25, color: '#654321', type: 'floating' },
                { x: 450, y: 480, width: 150, height: 25, color: '#654321', type: 'floating' },
                { x: 750, y: 520, width: 150, height: 25, color: '#654321', type: 'floating' },
                { x: 1100, y: 500, width: 150, height: 25, color: '#654321', type: 'floating' },
                { x: 1350, y: 460, width: 150, height: 25, color: '#654321', type: 'floating' },
                
                // Level 3
                { x: 100, y: 380, width: 120, height: 25, color: '#A0522D', type: 'floating' },
                { x: 350, y: 350, width: 120, height: 25, color: '#A0522D', type: 'floating' },
                { x: 600, y: 320, width: 120, height: 25, color: '#A0522D', type: 'floating' },
                { x: 900, y: 340, width: 120, height: 25, color: '#A0522D', type: 'floating' },
                { x: 1200, y: 300, width: 120, height: 25, color: '#A0522D', type: 'floating' },
                
                // Top level
                { x: 250, y: 200, width: 100, height: 25, color: '#8B6914', type: 'floating' },
                { x: 500, y: 180, width: 100, height: 25, color: '#8B6914', type: 'floating' },
                { x: 800, y: 160, width: 100, height: 25, color: '#8B6914', type: 'floating' },
                { x: 1100, y: 140, width: 100, height: 25, color: '#8B6914', type: 'floating' }
            ];
        }

        // Enhanced shape drawing with more shapes
        function drawShape(context, shape, color, x, y, size) {
            context.fillStyle = color;
            context.strokeStyle = '#333';
            context.lineWidth = 3;
            context.shadowColor = 'rgba(0,0,0,0.3)';
            context.shadowBlur = 5;
            context.shadowOffsetX = 2;
            context.shadowOffsetY = 2;

            const centerX = x + size / 2;
            const centerY = y + size / 2;
            const radius = size / 3;

            context.beginPath();
            
            switch(shape) {
                case 'circle':
                    context.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    break;
                    
                case 'square':
                    context.rect(centerX - radius, centerY - radius, radius * 2, radius * 2);
                    break;
                    
                case 'triangle':
                    context.moveTo(centerX, centerY - radius);
                    context.lineTo(centerX - radius, centerY + radius);
                    context.lineTo(centerX + radius, centerY + radius);
                    context.closePath();
                    break;
                    
                case 'diamond':
                    context.moveTo(centerX, centerY - radius);
                    context.lineTo(centerX + radius, centerY);
                    context.lineTo(centerX, centerY + radius);
                    context.lineTo(centerX - radius, centerY);
                    context.closePath();
                    break;
                    
                case 'star':
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                        const x1 = centerX + Math.cos(angle) * radius;
                        const y1 = centerY + Math.sin(angle) * radius;
                        if (i === 0) context.moveTo(x1, y1);
                        else context.lineTo(x1, y1);
                        
                        const innerAngle = angle + Math.PI / 5;
                        const x2 = centerX + Math.cos(innerAngle) * (radius * 0.4);
                        const y2 = centerY + Math.sin(innerAngle) * (radius * 0.4);
                        context.lineTo(x2, y2);
                    }
                    context.closePath();
                    break;
                    
                case 'hexagon':
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI * 2) / 6;
                        const x1 = centerX + Math.cos(angle) * radius;
                        const y1 = centerY + Math.sin(angle) * radius;
                        if (i === 0) context.moveTo(x1, y1);
                        else context.lineTo(x1, y1);
                    }
                    context.closePath();
                    break;
                    
                case 'heart':
                    const heartSize = radius * 0.8;
                    context.moveTo(centerX, centerY + heartSize * 0.3);
                    context.bezierCurveTo(centerX - heartSize, centerY - heartSize * 0.5, 
                                        centerX - heartSize * 0.5, centerY - heartSize, 
                                        centerX, centerY - heartSize * 0.3);
                    context.bezierCurveTo(centerX + heartSize * 0.5, centerY - heartSize, 
                                        centerX + heartSize, centerY - heartSize * 0.5, 
                                        centerX, centerY + heartSize * 0.3);
                    context.closePath();
                    break;
            }
            
            context.fill();
            context.stroke();
            
            // Reset shadow
            context.shadowColor = 'transparent';
            context.shadowBlur = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
        }

        function generateBackground() {
            clouds = [];
            for (let i = 0; i < 8; i++) {
                clouds.push({
                    x: Math.random() * 2000,
                    y: 50 + Math.random() * 150,
                    size: 30 + Math.random() * 50,
                    speed: 0.2 + Math.random() * 0.8,
                    opacity: 0.3 + Math.random() * 0.4
                });
            }
        }

        function initLevel() {
            generatePlatforms();
            generateBackground();
            
            // Set new target for level
            currentTarget.shape = shapes[Math.floor(Math.random() * shapes.length)];
            currentTarget.color = colors[Math.floor(Math.random() * colors.length)];
            
            gameState.collected = 0;
            gameState.targetCount = Math.min(5 + Math.floor(gameState.level / 2), 12);
            gameState.timeLeft = Math.max(45, 70 - gameState.level * 3);
            
            generateCollectibles();
            updateTargetDisplay();
            updateUI();
            
            // Reset player position
            player.x = 100;
            player.y = 500;
            player.velocityX = 0;
            player.velocityY = 0;
            player.onGround = false;
            player.canDoubleJump = true;
        }

        function generateCollectibles() {
            collectibles = [];
            particles = [];
            let targetGenerated = 0;
            
            // Distribute collectibles across platforms
            platforms.forEach((platform, platformIndex) => {
                if (platform.type === 'ground' && platformIndex > 0) return; // Skip some ground platforms
                
                const itemsOnPlatform = Math.max(1, Math.floor(Math.random() * 3));
                
                for (let i = 0; i < itemsOnPlatform && collectibles.length < gameState.targetCount * 2.5; i++) {
                    const shouldBeTarget = targetGenerated < gameState.targetCount && 
                                         (Math.random() < 0.4 || targetGenerated < 2);
                    
                    let shape, color, isTarget;
                    
                    if (shouldBeTarget) {
                        shape = currentTarget.shape;
                        color = currentTarget.color;
                        isTarget = true;
                        targetGenerated++;
                    } else {
                        // Create decoy items
                        shape = shapes[Math.floor(Math.random() * shapes.length)];
                        color = colors[Math.floor(Math.random() * colors.length)];
                        isTarget = false;
                        
                        // Sometimes match either shape or color (but not both) for challenge
                        if (Math.random() < 0.3) {
                            if (Math.random() < 0.5) {
                                shape = currentTarget.shape; // Same shape, different color
                            } else {
                                color = currentTarget.color; // Same color, different shape
                            }
                        }
                    }
                    
                    collectibles.push({
                        x: platform.x + 30 + Math.random() * (platform.width - 80),
                        y: platform.y - 40,
                        width: 30,
                        height: 30,
                        shape: shape,
                        color: color,
                        isTarget: isTarget,
                        collected: false,
                        bounce: Math.random() * Math.PI * 2,
                        glowIntensity: isTarget ? 0.8 : 0
                    });
                }
            });
            
            // Ensure minimum target count
            while (targetGenerated < gameState.targetCount) {
                const platform = platforms[Math.floor(Math.random() * platforms.length)];
                collectibles.push({
                    x: platform.x + 30 + Math.random() * (platform.width - 80),
                    y: platform.y - 40,
                    width: 30,
                    height: 30,
                    shape: currentTarget.shape,
                    color: currentTarget.color,
                    isTarget: true,
                    collected: false,
                    bounce: Math.random() * Math.PI * 2,
                    glowIntensity: 0.8
                });
                targetGenerated++;
            }
        }

        function updateTargetDisplay() {
            targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
            
            // Add glow effect for target
            targetCtx.shadowColor = currentTarget.color;
            targetCtx.shadowBlur = 15;
            targetCtx.shadowOffsetX = 0;
            targetCtx.shadowOffsetY = 0;
            
            drawShape(targetCtx, currentTarget.shape, currentTarget.color, 15, 15, 50);
            
            document.getElementById('targetName').textContent = 
                `${shapeNames[currentTarget.shape]} ${colorNames[currentTarget.color]}`;
        }

        function updatePlayer() {
            const prevVelocityY = player.velocityY;
            
            // Handle crouching
            player.crouching = keys['KeyS'] || keys['ArrowDown'];
            
            // Horizontal movement with acceleration
            if (keys['ArrowLeft'] || keys['KeyA']) {
                player.velocityX = Math.max(player.velocityX - 1, -player.speed);
                player.facingRight = false;
            } else if (keys['ArrowRight'] || keys['KeyD']) {
                player.velocityX = Math.min(player.velocityX + 1, player.speed);
                player.facingRight = true;
            } else {
                player.velocityX *= 0.85; // Smooth deceleration
            }

            // Jumping with double jump
            if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && !player.wasJumping) {
                if (player.onGround) {
                    player.velocityY = -player.jumpPower;
                    player.onGround = false;
                    player.canDoubleJump = true;
                } else if (player.canDoubleJump) {
                    player.velocityY = -player.jumpPower * 0.8;
                    player.canDoubleJump = false;
                    createParticles(player.x + player.width/2, player.y + player.height, '#87CEEB', 5);
                }
                player.wasJumping = true;
            } else {
                player.wasJumping = false;
            }

            // Enhanced gravity and physics
            if (player.crouching && player.onGround) {
                player.velocityY += 2; // Fast fall
            } else {
                player.velocityY += 0.9; // Gravity
            }
            
            // Terminal velocity
            player.velocityY = Math.min(player.velocityY, 20);

            // Update position
            player.x += player.velocityX;
            player.y += player.velocityY;

            // Enhanced collision detection
            player.onGround = false;
            platforms.forEach(platform => {
                if (player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {
                    
                    // Top collision (landing)
                    if (prevVelocityY >= 0 && player.y < platform.y) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        player.canDoubleJump = true;
                    }
                    // Bottom collision
                    else if (prevVelocityY < 0 && player.y > platform.y) {
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                    }
                    // Side collisions
                    else if (player.velocityX > 0 && player.x < platform.x) {
                        player.x = platform.x - player.width;
                        player.velocityX = 0;
                    }
                    else if (player.velocityX < 0 && player.x > platform.x) {
                        player.x = platform.x + platform.width;
                        player.velocityX = 0;
                    }
                }
            });

            // World boundaries
            if (player.x < 0) {
                player.x = 0;
                player.velocityX = 0;
            }
            if (player.x > 1800 - player.width) {
                player.x = 1800 - player.width;
                player.velocityX = 0;
            }
            
            // Fall off world - respawn
            if (player.y > canvas.height + 100) {
                respawnPlayer();
            }

            // Update camera with smooth following
            const targetCameraX = player.x - canvas.width / 2;
            gameState.camera.x += (targetCameraX - gameState.camera.x) * 0.1;
            gameState.camera.x = Math.max(0, Math.min(gameState.camera.x, 1800 - canvas.width));
            
            // Animation frame for player sprite
            player.animationFrame += 0.2;
            if (player.animationFrame > 2) player.animationFrame = 0;
        }

        function respawnPlayer() {
            player.x = 100;
            player.y = 500;
            player.velocityX = 0;
            player.velocityY = 0;
            gameState.timeLeft = Math.max(gameState.timeLeft - 5, 0);
            createSoundEffect("üíî", player.x, player.y, '#FF6B6B');
        }

        function updateCollectibles() {
            collectibles.forEach((item, index) => {
                if (item.collected) return;
                
                // Enhanced bounce animation
                item.bounce += 0.15;
                const bounceY = Math.sin(item.bounce) * 8;
                
                // Glow effect for target items
                if (item.isTarget) {
                    item.glowIntensity = 0.5 + Math.sin(item.bounce * 2) * 0.3;
                }
                
                // Collision detection with enhanced feedback
                if (player.x < item.x + item.width &&
                    player.x + player.width > item.x &&
                    player.y < item.y + bounceY + item.height &&
                    player.y + player.height > item.y + bounceY) {
                    
                    item.collected = true;
                    
                    if (item.isTarget) {
                        // Correct target collected
                        gameState.collected++;
                        const basePoints = 100;
                        const speedBonus = Math.max(0, gameState.timeLeft - 30) * 2;
                        const levelBonus = gameState.level * 10;
                        const totalPoints = basePoints + speedBonus + levelBonus;
                        
                        gameState.score += totalPoints;
                        gameState.bonus += speedBonus;
                        gameState.perfectStreak++;
                        
                        createParticles(item.x, item.y, item.color, 12);
                        createSoundEffect(`+${totalPoints}`, item.x, item.y, '#FFD700');
                        
                        // Check level completion
                        if (gameState.collected >= gameState.targetCount) {
                            setTimeout(() => levelComplete(), 500);
                        }
                    } else {
                        // Wrong item collected
                        const penalty = 50;
                        gameState.score = Math.max(0, gameState.score - penalty);
                        gameState.perfectStreak = 0;
                        gameState.timeLeft = Math.max(0, gameState.timeLeft - 3);
                        
                        createParticles(item.x, item.y, '#FF0000', 8);
                        createSoundEffect(`-${penalty}`, item.x, item.y, '#FF0000');
                        
                        // Screen shake effect
                        shakeScreen();
                    }
                    
                    updateUI();
                }
            });
        }

        function createParticles(x, y, color, count = 8, type = 'burst') {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x + 15,
                    y: y + 15,
                    velocityX: (Math.random() - 0.5) * 12,
                    velocityY: (Math.random() - 0.5) * 12 - Math.random() * 5,
                    color: color,
                    life: 40 + Math.random() * 20,
                    maxLife: 40 + Math.random() * 20,
                    size: 3 + Math.random() * 4,
                    type: type
                });
            }
        }

        function createSoundEffect(text, x, y, color) {
            soundEffects.push({
                text: text,
                x: x - gameState.camera.x,
                y: y,
                color: color,
                life: 60,
                velocityY: -2
            });
        }

        function shakeScreen() {
            const originalX = gameState.camera.x;
            let shakeIntensity = 10;
            let shakeDuration = 15;
            
            const shake = () => {
                if (shakeDuration > 0) {
                    gameState.camera.x = originalX + (Math.random() - 0.5) * shakeIntensity;
                    shakeIntensity *= 0.9;
                    shakeDuration--;
                    requestAnimationFrame(shake);
                } else {
                    gameState.camera.x = originalX;
                }
            };
            shake();
        }

        function updateParticles() {
            particles.forEach((particle, index) => {
                particle.x += particle.velocityX;
                particle.y += particle.velocityY;
                particle.velocityY += 0.4; // Gravity
                particle.velocityX *= 0.98; // Air resistance
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });
        }

        function updateSoundEffects() {
            soundEffects.forEach((effect, index) => {
                effect.y += effect.velocityY;
                effect.life--;
                
                if (effect.life <= 0) {
                    soundEffects.splice(index, 1);
                }
            });
        }

        function drawBackground() {
            // Enhanced sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(0.7, '#98FB98');
            skyGradient.addColorStop(1, '#90EE90');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(gameState.camera.x, 0, canvas.width, canvas.height);
            
            // Parallax clouds
            clouds.forEach(cloud => {
                const parallaxX = cloud.x - gameState.camera.x * cloud.speed;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${cloud.opacity})`;
                ctx.beginPath();
                ctx.arc(parallaxX, cloud.y, cloud.size, 0, Math.PI * 2);
                ctx.arc(parallaxX + cloud.size * 0.6, cloud.y, cloud.size * 0.8, 0, Math.PI * 2);
                ctx.arc(parallaxX + cloud.size * 1.2, cloud.y, cloud.size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                cloud.x += cloud.speed * 0.3;
                if (cloud.x > 2200) {
                    cloud.x = -200;
                    cloud.y = 50 + Math.random() * 150;
                }
            });
        }

        function drawPlatforms() {
            platforms.forEach(platform => {
                const screenX = platform.x - gameState.camera.x;
                
                // Only draw visible platforms
                if (screenX > -platform.width && screenX < canvas.width) {
                    // Platform shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.fillRect(screenX + 3, platform.y + 3, platform.width, platform.height);
                    
                    // Main platform
                    ctx.fillStyle = platform.color;
                    ctx.fillRect(screenX, platform.y, platform.width, platform.height);
                    
                    // Highlight
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.fillRect(screenX, platform.y, platform.width, 8);
                    
                    // Texture lines
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < platform.width; i += 20) {
                        ctx.beginPath();
                        ctx.moveTo(screenX + i, platform.y);
                        ctx.lineTo(screenX + i, platform.y + platform.height);
                        ctx.stroke();
                    }
                }
            });
        }

        function drawCollectibles() {
            collectibles.forEach(item => {
                if (item.collected) return;
                
                const screenX = item.x - gameState.camera.x;
                
                // Only draw visible items
                if (screenX > -item.width && screenX < canvas.width) {
                    const bounceY = Math.sin(item.bounce) * 8;
                    
                    // Glow effect for target items
                    if (item.isTarget && item.glowIntensity > 0) {
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 15 * item.glowIntensity;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
                    
                    drawShape(ctx, item.shape, item.color, screenX, item.y + bounceY, item.width);
                    
                    // Target highlight ring
                    if (item.isTarget) {
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = 4;
                        ctx.globalAlpha = item.glowIntensity;
                        ctx.beginPath();
                        ctx.arc(screenX + item.width/2, item.y + bounceY + item.height/2, 
                               item.width/2 + 8, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
            });
        }

 Math.sin(player.animationFrame) * 2;
            ctx.fillRect(screenX + player.width/2 - 8, drawY - 10 + eyeOffset, 3, 3);
            ctx.fillRect(screenX + player.width/2 + 5, drawY - 10 + eyeOffset, 3, 3);
            
            // Smile
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(screenX + player.width/2, drawY - 2, 8, 0, Math.PI);
            ctx.stroke();
            
            // Arms with movement
            ctx.strokeStyle = player.color;
            ctx.lineWidth = 6;
            const armSwing = Math.sin(player.animationFrame * Math.PI) * 5;
            
            ctx.beginPath();
            ctx.moveTo(screenX + 8, drawY + 15);
            ctx.lineTo(screenX + 3 - armSwing, drawY + 25 + armSwing);
            ctx.moveTo(screenX + player.width - 8, drawY + 15);
            ctx.lineTo(screenX + player.width - 3 + armSwing, drawY + 25 - armSwing);
            ctx.stroke();
            
            // Movement indicators
            if (Math.abs(player.velocityX) > 1) {
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(screenX - 20 - i*8, drawY + 20 + i*5, 4, 2);
                }
            }
            
            // Jump indicator
            if (!player.onGround) {
                ctx.strokeStyle = 'rgba(135,206,235,0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX + player.width/2, drawY + player.height/2, 30, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function drawParticles() {
            particles.forEach(particle => {
                const screenX = particle.x - gameState.camera.x;
                
                if (screenX > -10 && screenX < canvas.width + 10) {
                    ctx.fillStyle = particle.color;
                    ctx.globalAlpha = particle.life / particle.maxLife;
                    
                    const size = particle.size * (particle.life / particle.maxLife);
                    ctx.fillRect(screenX - size/2, particle.y - size/2, size, size);
                    
                    ctx.globalAlpha = 1;
                }
            });
        }

        function drawSoundEffects() {
            soundEffects.forEach(effect => {
                ctx.fillStyle = effect.color;
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.globalAlpha = effect.life / 60;
                
                // Text outline
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(effect.text, effect.x, effect.y);
                ctx.fillText(effect.text, effect.x, effect.y);
                
                ctx.globalAlpha = 1;
            });
        }

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();
            drawPlatforms();
            drawCollectibles();
            drawParticles();
            drawPlayer();
            drawSoundEffects();
            
            // Progress visualization
            const progress = gameState.collected / gameState.targetCount;
            document.getElementById('progressFill').style.width = (progress * 100) + '%';
        }

        function updateUI() {
            document.getElementById('score').textContent = gameState.score.toLocaleString();
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('collected').textContent = gameState.collected;
            document.getElementById('targetCount').textContent = gameState.targetCount;
            document.getElementById('timer').textContent = Math.max(0, gameState.timeLeft);
            document.getElementById('bonus').textContent = gameState.bonus.toLocaleString();
        }

        function levelComplete() {
            gameState.gameRunning = false;
            
            const timeBonus = gameState.timeLeft * 10;
            const perfectBonus = gameState.perfectStreak >= gameState.targetCount ? 500 : 0;
            const levelBonus = gameState.level * 100;
            
            gameState.score += timeBonus + perfectBonus + levelBonus;
            
            const modal = document.getElementById('levelCompleteModal');
            const content = document.getElementById('levelCompleteContent');
            
            content.innerHTML = `
                üéâ <strong>Level ${gameState.level} Berhasil Diselesaikan!</strong><br><br>
                
                üìä <strong>Statistik Level:</strong><br>
                ‚≠ê Bentuk dikumpulkan: ${gameState.collected}/${gameState.targetCount}<br>
                ‚è±Ô∏è Waktu tersisa: ${gameState.timeLeft} detik<br>
                üéØ Target: ${shapeNames[currentTarget.shape]} ${colorNames[currentTarget.color]}<br><br>
                
                üèÜ <strong>Bonus Poin:</strong><br>
                ‚ö° Bonus waktu: +${timeBonus}<br>
                üéØ Bonus level: +${levelBonus}<br>
                ${perfectBonus > 0 ? `‚ú® Bonus sempurna: +${perfectBonus}<br>` : ''}
                <strong>Total Skor: ${gameState.score.toLocaleString()}</strong><br><br>
                
                ${gameState.level >= gameState.maxLevels ? 
                    'üèÜ <strong>Selamat! Anda telah menyelesaikan semua level!</strong>' :
                    'üöÄ Siap untuk tantangan berikutnya?'
                }
            `;
            
            modal.style.display = 'block';
        }

        function nextLevel() {
            if (gameState.level >= gameState.maxLevels) {
                showVictory();
                return;
            }
            
            gameState.level++;
            gameState.perfectStreak = 0;
            
            document.getElementById('levelCompleteModal').style.display = 'none';
            
            initLevel();
            gameState.gameRunning = true;
        }

        function showVictory() {
            const modal = document.getElementById('victoryModal');
            const content = document.getElementById('victoryContent');
            
            content.innerHTML = `
                üéä <strong>SELAMAT CHAMPION!</strong> üéä<br><br>
                
                Anda telah menyelesaikan semua ${gameState.maxLevels} level!<br><br>
                
                üèÜ <strong>Statistik Final:</strong><br>
                üìä Skor Total: ${gameState.score.toLocaleString()}<br>
                üéØ Bonus Total: ${gameState.bonus.toLocaleString()}<br>
                ‚≠ê Level Tertinggi: ${gameState.level}<br><br>
                
                üåü Anda adalah <strong>MASTER SHAPE HUNTER</strong>!<br>
                Kemampuan mengenali bentuk dan warna Anda luar biasa!<br><br>
                
                Terima kasih telah bermain dan belajar bersama kami! üéÆ‚ú®
            `;
            
            document.getElementById('levelCompleteModal').style.display = 'none';
            modal.style.display = 'block';
        }

        function gameOver() {
            gameState.gameRunning = false;
            
            const modal = document.getElementById('gameOverModal');
            const content = document.getElementById('gameOverContent');
            
            content.innerHTML = `
                ‚è∞ <strong>Waktu Habis di Level ${gameState.level}!</strong><br><br>
                
                üìä <strong>Progress Level Ini:</strong><br>
                ‚≠ê Dikumpulkan: ${gameState.collected}/${gameState.targetCount}<br>
                üéØ Target: ${shapeNames[currentTarget.shape]} ${colorNames[currentTarget.color]}<br>
                üèÜ Skor Saat Ini: ${gameState.score.toLocaleString()}<br><br>
                
                üí° <strong>Tips untuk percobaan berikutnya:</strong><br>
                ‚Ä¢ Fokus pada bentuk dan warna target<br>
                ‚Ä¢ Hindari bentuk yang berbeda untuk menghemat waktu<br>
                ‚Ä¢ Gunakan lompatan ganda untuk jangkauan lebih tinggi<br>
                ‚Ä¢ Gerak cepat untuk mendapat bonus waktu!<br><br>
                
                Jangan menyerah, terus berlatih! üí™
            `;
            
            modal.style.display = 'block';
        }

        function restartCurrentLevel() {
            document.getElementById('gameOverModal').style.display = 'none';
            initLevel();
            gameState.gameRunning = true;
        }

        function restartGame() {
            // Hide all modals
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('levelCompleteModal').style.display = 'none';
            document.getElementById('victoryModal').style.display = 'none';
            document.getElementById('startModal').style.display = 'block';
            
            // Reset game state
            gameState = {
                score: 0,
                level: 1,
                collected: 0,
                targetCount: 5,
                timeLeft: 60,
                gameRunning: false,
                gameStarted: false,
                camera: { x: 0, y: 0 },
                maxLevels: 10,
                bonus: 0,
                perfectStreak: 0
            };
            
            // Reset player
            player.x = 100;
            player.y = 500;
            player.velocityX = 0;
            player.velocityY = 0;
            player.onGround = false;
            player.canDoubleJump = true;
            
            // Clear arrays
            particles = [];
            soundEffects = [];
            
            updateUI();
        }

        function startGame() {
            document.getElementById('startModal').style.display = 'none';
            gameState.gameStarted = true;
            gameState.gameRunning = true;
            initLevel();
        }

        function showInstructions() {
            document.getElementById('startModal').style.display = 'none';
            document.getElementById('instructionsModal').style.display = 'block';
        }

        function hideInstructions() {
            document.getElementById('instructionsModal').style.display = 'none';
            document.getElementById('startModal').style.display = 'block';
        }

        // Enhanced controls
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            e.preventDefault();
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Mobile controls
        document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['KeyA'] = true;
        });
        document.getElementById('leftBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['KeyA'] = false;
        });

        document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['KeyD'] = true;
        });
        document.getElementById('rightBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['KeyD'] = false;
        });

        document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['Space'] = true;
        });
        document.getElementById('jumpBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['Space'] = false;
        });

        document.getElementById('downBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['KeyS'] = true;
        });
        document.getElementById('downBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['KeyS'] = false;
        });

        // Game timer
        setInterval(() => {
            if (gameState.gameRunning && gameState.gameStarted) {
                gameState.timeLeft--;
                if (gameState.timeLeft <= 0) {
                    gameOver();
                }
                updateUI();
            }
        }, 1000);

        // Enhanced game loop
        function gameLoop() {
            if (gameState.gameRunning && gameState.gameStarted) {
                updatePlayer();
                updateCollectibles();
                updateParticles();
                updateSoundEffects();
            }
            
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // Initialize
        updateUI();
        gameLoop();
    </script>
</body>
</html>